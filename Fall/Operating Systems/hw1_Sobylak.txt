Eli Sobylak
30-sept-15

Ch 1: 1.1, 1.2, 1.3, 1.4, 1.6, 1.10, *1.7

1.1 
	a. Load AC from device 5
		1 9 4 1
	b. Add contents of memory location 940
		5 9 4 0
	c. Store AC to device 6
		2 9 4 2

1.2	The figure 1.4 is depicting the program execution trace and it adds 2 and 3 together to make 5 and then store it in memory. The MAR and MBR and not shown but certainly in use during this program. The MAR (memory access register) is responsible for accessing locations in memory, and then puts it in to the MBR (memory buffer register) which then holds on to it until the PC or IR needs new data.

1.3 	
	a. If it has 32-bit instructions and the first byte contains the opcode, then there are 2^24 bits or 2097152 bytes 
	b. 
		1. If you have a 32-bit local address bus and a 16-bit local data bus, there would be a non even distribution and the system speed would be impacted.
		2. If you have a 16-bit local address bus and a 16-bit local data bus, the system speed would be consistent and not change during processes.  
	 1.4	
	a. The maximum address space would be 2^16-1
	b. The max memory address space the processor could access would be 2^8-1
	c. An I/O buffer would be needed to help make sure the processor doesn’t drop 		   processes
	d. It would be able to support one 8-bit I/O port and two 16-bit I/O ports

1.6	
	a. In this example the teletype gets input in the form of keystrokes and would store the data in the Input Register. Then, this would set the Input Flag. After this the decoded alphanumeric symbol is moved to the Output register which then sets the Output Flag.
	b. To do this function more efficiently you could use the Interrupt Enable. Interrupts would allow for the program to run concurrently with the interrupts to handle things like outputs and inputs.

1.10
	a. One example of spacial locality in this code which is two for loops nested, while performing the loops the memory will be accessed closer together since the same opcodes are being used again and again. 
	b. Again, due to the nested for loops, this codes also exhibits temporal locality because at a given time during the execution stack and the processor are primarily working with fixed clusters of memory. 

*1.7	DMA (direct memory access) is usually given higher priority to main memory than processor access because DMA us far more efficient than interrupt-driven or programmed I/O. This is because the DMA module transfers entire blocks of data, one word at a time, to or from memory without going through the processor. The processor does not need to stop work or save its state. It’s only supervision is needed at the begging and the end of the transfer.